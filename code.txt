<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Shadow Sprint: 25 Trials</title>
<style>
  :root {
    --bg: #06080d;
    --panel: rgba(10, 14, 22, 0.72);
    --panel-border: rgba(255, 255, 255, 0.08);
    --text: rgba(255, 255, 255, 0.92);
    --muted: rgba(255, 255, 255, 0.6);
    --accent: #9cf7ff;
    --danger: #ff5b5b;
    --good: #71ffb0;
  }
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: var(--bg);
    font-family: "Segoe UI", system-ui, sans-serif;
    color: var(--text);
  }
  canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    background: #05070c;
    z-index: 1;
  }
  .ui {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 2;
  }
  .ui .panel,
  .ui .controls,
  .ui button,
  .ui .hint {
    pointer-events: auto;
  }
  .panel {
    background: var(--panel);
    border: 1px solid var(--panel-border);
    border-radius: 12px;
    padding: 10px 14px;
    backdrop-filter: blur(10px);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
  }
  .top {
    position: absolute;
    left: 16px;
    top: 16px;
    right: 16px;
    display: flex;
    justify-content: space-between;
    gap: 12px;
    align-items: flex-start;
  }
  .stats {
    display: flex;
    gap: 16px;
    align-items: center;
    font-size: 14px;
  }
  .stats strong { font-size: 18px; }
  .controls { pointer-events: auto; display: flex; gap: 8px; }
  button {
    appearance: none;
    border: 1px solid rgba(255, 255, 255, 0.14);
    background: rgba(255, 255, 255, 0.06);
    color: var(--text);
    padding: 8px 12px;
    border-radius: 10px;
    font-size: 13px;
    cursor: pointer;
    transition: transform 0.2s ease, background 0.2s ease;
  }
  button:hover { transform: translateY(-1px); background: rgba(255, 255, 255, 0.14); }
  button:active { transform: translateY(0); }
  .hint {
    position: absolute;
    left: 16px;
    top: 70px;
    max-width: 320px;
    line-height: 1.4;
    font-size: 13px;
    pointer-events: auto;
  }
  .hint h4 { margin: 0 0 8px; font-size: 14px; letter-spacing: 0.05em; }
  .center {
    position: absolute;
    left: 50%;
    top: 45%;
    transform: translate(-50%, -50%);
    text-align: center;
    pointer-events: none;
  }
  .center h1 { margin: 0; font-size: 34px; letter-spacing: 0.08em; text-transform: uppercase; }
  .center p { margin: 12px 0 0; color: var(--muted); }
  .boss-bar {
    position: absolute;
    left: 50%;
    top: 16px;
    transform: translateX(-50%);
    width: min(520px, 90vw);
    height: 12px;
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.14);
    overflow: hidden;
    pointer-events: none;
  }
  .boss-bar span {
    display: block;
    height: 100%;
    background: linear-gradient(90deg, #ff8b8b, #ff2d2d);
    width: 100%;
  }
  .mute-indicator {
    position: absolute;
    right: 18px;
    bottom: 20px;
    font-size: 12px;
    color: var(--muted);
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="ui">
  <div class="top">
    <div class="panel stats">
      <div>Уровень <strong id="level">1</strong>/25</div>
      <div>Время <strong id="timer">0.0</strong>с</div>
      <div id="par" style="display:none;">Пар <strong id="parTime">0.0</strong>с</div>
    </div>
    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="muteBtn">Mute (M)</button>
      <button id="hintBtn">Controls (H)</button>
    </div>
  </div>
  <div class="panel hint" id="hint">
    <h4>Управление</h4>
    <div>WASD — движение</div>
    <div>Space — прыжок (двойной)</div>
    <div>Ctrl — присесть (низкий хитбокс)</div>
    <div>Shift — быстрый бег</div>
    <div>ЛКМ — атака тенью (нужна на боссе)</div>
    <div>ПКМ — управление камерой (осмотр)</div>
    <div>H — свернуть подсказку</div>
    <div>M — звук</div>
  </div>
  <div class="center" id="center">
    <h1>Shadow Sprint</h1>
    <p>25 процедурных испытаний. Нажми Start.</p>
  </div>
  <div class="boss-bar" id="bossBar" style="display:none;"><span></span></div>
  <div class="mute-indicator" id="muteIndicator">Sound: ON</div>
</div>
<script>
(() => {
  "use strict";
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const hudLevel = document.getElementById("level");
  const hudTimer = document.getElementById("timer");
  const hudPar = document.getElementById("par");
  const hudParTime = document.getElementById("parTime");
  const hint = document.getElementById("hint");
  const hintBtn = document.getElementById("hintBtn");
  const startBtn = document.getElementById("startBtn");
  const muteBtn = document.getElementById("muteBtn");
  const center = document.getElementById("center");
  const bossBar = document.getElementById("bossBar");
  const bossBarFill = bossBar.querySelector("span");
  const muteIndicator = document.getElementById("muteIndicator");

  const state = {
    running: false,
    level: 1,
    seed: 1,
    attempt: 0,
    time: 0,
    par: 0,
    rng: null,
    paused: false,
    muted: false,
    shake: 0,
    camera: { x: 0, y: 0, tx: 0, ty: 0, manual: false, offsetX: 0, offsetY: 0 },
  };

  const input = {
    left: false, right: false, up: false, down: false,
    jump: false, sprint: false, attack: false,
    jumpBuffer: 0,
    sprintBuffer: 0,
    mouse: { x: 0, y: 0, down: false, rdown: false, dragX: 0, dragY: 0 },
  };

  const world = {
    width: 3000,
    height: 900,
    gravity: 0.8,
    platforms: [],
    hazards: [],
    enemies: [],
    bullets: [],
    particles: [],
    pickups: [],
    portals: [],
    decorations: [],
    boss: null,
  };

  const player = {
    x: 100, y: 100, w: 26, h: 40,
    vx: 0, vy: 0,
    onGround: false,
    coyote: 0,
    jumpReady: true,
    jumpsLeft: 2,
    crouch: false,
    invuln: 0,
    attackCooldown: 0,
  };

  let audioCtx = null;
  let musicGain = null;
  let sfxGain = null;
  let musicTimer = 0;
  let musicStep = 0;

  const DPR = () => window.devicePixelRatio || 1;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = () => state.rng();

  function resize() {
    const dpr = DPR();
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  function mulberry32(a) {
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function setSeed(level, attempt) {
    state.seed = (level * 99991 + attempt * 1013 + 1337) >>> 0;
    state.rng = mulberry32(state.seed);
  }

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    musicGain = audioCtx.createGain();
    sfxGain = audioCtx.createGain();
    musicGain.connect(audioCtx.destination);
    sfxGain.connect(audioCtx.destination);
    updateMute();
  }

  function updateMute() {
    if (!audioCtx) return;
    const target = state.muted ? 0 : 0.28;
    musicGain.gain.value = target;
    sfxGain.gain.value = state.muted ? 0 : 0.6;
    muteIndicator.textContent = `Sound: ${state.muted ? "OFF" : "ON"}`;
  }

  function playTone(freq, type, duration, gain = 0.5) {
    if (!audioCtx || state.muted) return;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.value = gain;
    osc.connect(g);
    g.connect(sfxGain);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(gain, now);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.start(now);
    osc.stop(now + duration + 0.05);
  }

  function playNoise(duration, gain = 0.4) {
    if (!audioCtx || state.muted) return;
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buffer;
    g.gain.value = gain;
    src.connect(g);
    g.connect(sfxGain);
    src.start();
  }

  function musicStepTick(dt) {
    if (!audioCtx || state.muted || !state.running) return;
    musicTimer += dt;
    const tempo = lerp(0.42, 0.22, clamp((state.level - 1) / 24, 0, 1));
    if (musicTimer < tempo) return;
    musicTimer = 0;
    const scale = [0, 3, 5, 7, 10, 12];
    const base = 110 + state.level * 3;
    const phase = Math.floor(state.level / 5) % 4;
    const chord = [0, 4, 7, 10][phase % 4];
    const note = scale[(musicStep + phase) % scale.length] + chord;
    const freq = base * Math.pow(2, note / 12);
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = "triangle";
    osc.frequency.value = freq;
    g.gain.value = 0.16;
    osc.connect(g);
    g.connect(musicGain);
    const now = audioCtx.currentTime;
    g.gain.setValueAtTime(0.16, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
    osc.start(now);
    osc.stop(now + 0.3);
    musicStep++;
  }

  function spawnParticle(x, y, color, count = 12, speed = 2, life = 40) {
    for (let i = 0; i < count; i++) {
      world.particles.push({
        x, y,
        vx: (rand() * 2 - 1) * speed,
        vy: (rand() * 2 - 1) * speed,
        life: life + rand() * 10,
        color,
        size: 1 + rand() * 2
      });
    }
  }

  function resetWorld() {
    world.platforms = [];
    world.hazards = [];
    world.enemies = [];
    world.bullets = [];
    world.particles = [];
    world.pickups = [];
    world.portals = [];
    world.decorations = [];
    world.boss = null;
  }

  function addPlatform(x, y, w, h, type = "solid", extra = {}) {
    world.platforms.push({ x, y, w, h, type, ...extra });
  }

  function addHazard(x, y, w, h, type = "spike", extra = {}) {
    world.hazards.push({ x, y, w, h, type, ...extra });
  }

  function addEnemy(x, y, type = "walker", extra = {}) {
    const enemy = { x, y, w: 26, h: 26, type, vx: (rand() > 0.5 ? 1 : -1) * (1 + rand()), vy: 0, hp: 2, timer: 0, ...extra };
    world.enemies.push(enemy);
  }

  function addPortal(x, y, w, h, targetX = null) {
    world.portals.push({ x, y, w, h, targetX, active: true });
  }

  function generateLevel(level) {
    resetWorld();
    setSeed(level, state.attempt);
    const theme = Math.floor((level - 1) / 5);
    const length = 1600 + level * 140;
    world.width = length + 400;
    world.height = 900;

    const baseY = 640 - theme * 20;
    let x = 80;
    let y = baseY;
    addPlatform(0, baseY + 80, world.width, 120, "ground");

    const maxJumpX = 220 - level * 2;
    const maxUp = 120 - theme * 8;
    const maxDown = 180;

    for (let i = 0; i < 28 + level; i++) {
      const w = 90 + rand() * 140;
      const gap = 40 + rand() * 120 + level * 2;
      const dx = clamp(gap, 40, maxJumpX + 60);
      x += dx;
      y += (rand() * 2 - 1) * maxUp;
      y = clamp(y, 260, 600);

      const moving = level >= 10 && rand() > 0.7;
      const breakable = rand() > (0.92 - level * 0.005);
      addPlatform(x, y, w, 20, moving ? "moving" : (breakable ? "fragile" : "solid"), {
        startX: x,
        range: moving ? 80 + rand() * 140 : 0,
        speed: moving ? 0.5 + rand() * 1.2 : 0,
        fallTimer: 0,
      });

      if (level >= 6 && rand() > 0.7) {
        addEnemy(x + w * 0.4, y - 30, rand() > 0.5 ? "shooter" : "walker", { patrol: [x, x + w] });
      }

      if (rand() > 0.6) {
        addHazard(x + w * 0.2, y + 20, w * 0.5, 18, "spike");
      }

      if (level >= 10 && rand() > 0.7) {
        addHazard(x + w * 0.6, y - 40, 36, 36, "saw", { r: 18, phase: rand() * Math.PI * 2, speed: 0.03 + rand() * 0.05 });
      }

      if (level >= 15 && rand() > 0.65) {
        addHazard(x + w * 0.3, y - 140, 140, 8, "laser", { phase: rand() * Math.PI * 2, speed: 0.015 + rand() * 0.02 });
      }

      if (level >= 12 && rand() > 0.7) {
        const portalX = x + w * 0.8;
        addPortal(portalX, y - 40, 24, 40, portalX + 200 + rand() * 200);
      }

      if (rand() > 0.8) {
        world.pickups.push({
          x: x + w * 0.5,
          y: y - 30,
          type: rand() > 0.5 ? "buff" : "debuff",
          used: false,
        });
      }
    }

    addPortal(length + 80, y - 50, 40, 60, null);

    if (level === 25) {
      generateBossArena();
    }

    player.x = 80;
    player.y = baseY - 120;
    player.vx = 0;
    player.vy = 0;
    player.onGround = false;
    player.coyote = 0;
    player.jumpsLeft = 2;
    player.invuln = 0;
    player.attackCooldown = 0;

    state.time = 0;
    state.par = level >= 10 ? 14 + level * 1.2 : 0;
    hudPar.style.display = level >= 10 ? "block" : "none";
    hudParTime.textContent = state.par.toFixed(1);
    bossBar.style.display = level === 25 ? "block" : "none";
    center.style.display = "none";
    playTone(320, "sine", 0.2, 0.4);
  }

  function generateBossArena() {
    resetWorld();
    world.width = 2000;
    world.height = 900;
    const ground = 650;
    addPlatform(0, ground, world.width, 120, "ground");
    addPlatform(300, 520, 200, 20, "solid");
    addPlatform(700, 450, 200, 20, "solid");
    addPlatform(1100, 520, 200, 20, "solid");
    addPlatform(1500, 450, 200, 20, "solid");
    addHazard(500, ground + 10, 120, 20, "spike");
    addHazard(1000, ground + 10, 120, 20, "spike");
    addHazard(1400, ground + 10, 120, 20, "spike");
    world.boss = {
      x: 1500,
      y: ground - 120,
      w: 80,
      h: 100,
      hp: 120,
      maxHp: 120,
      phase: 1,
      timer: 0,
      vx: -2,
      vy: 0,
      attackTimer: 0,
      dashCooldown: 0,
    };
    addPortal(world.width - 120, ground - 60, 40, 60, null);
  }

  function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function playerRect() {
    return { x: player.x, y: player.y, w: player.w, h: player.crouch ? player.h * 0.6 : player.h };
  }

  function killPlayer() {
    spawnParticle(player.x + player.w / 2, player.y + player.h / 2, "rgba(255,90,90,0.9)", 18, 3, 40);
    playNoise(0.25, 0.5);
    state.shake = 18;
    state.attempt++;
    generateLevel(state.level);
  }

  function nextLevel() {
    if (state.level >= 25) {
      state.running = false;
      center.style.display = "block";
      center.innerHTML = "<h1>Victory</h1><p>Тьма повержена. Нажми Start для новой серии.</p>";
      return;
    }
    state.level++;
    state.attempt = 0;
    generateLevel(state.level);
  }

  function updatePlayer(dt) {
    const accel = player.onGround ? 0.9 : 0.5;
    const friction = player.onGround ? 0.75 : 0.92;
    const maxSpeed = input.sprint ? 7.2 : 5.2;
    const jumpVel = 12.5;

    const moveDir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
    player.vx += moveDir * accel;
    player.vx *= friction;
    player.vx = clamp(player.vx, -maxSpeed, maxSpeed);

    if (input.jumpBuffer > 0) input.jumpBuffer -= dt;
    if (input.sprintBuffer > 0) input.sprintBuffer -= dt;

    if (player.coyote > 0) player.coyote -= dt;
    if (player.invuln > 0) player.invuln -= dt;

    player.crouch = input.down;

    if (input.jumpBuffer > 0 && (player.onGround || player.coyote > 0 || player.jumpsLeft > 0)) {
      const groundedJump = player.onGround || player.coyote > 0;
      player.vy = -jumpVel;
      player.onGround = false;
      player.coyote = 0;
      input.jumpBuffer = 0;
      if (groundedJump) {
        player.jumpsLeft = 1;
      } else if (player.jumpsLeft > 0) {
        player.jumpsLeft -= 1;
      }
      playTone(320, "sine", 0.08, 0.4);
    }

    player.vy += world.gravity;

    player.x += player.vx;
    resolveCollisions("x");
    player.y += player.vy;
    resolveCollisions("y");

    if (player.y > world.height + 200) {
      killPlayer();
    }

    if (player.attackCooldown > 0) player.attackCooldown -= dt;
  }

  function resolveCollisions(axis) {
    const rect = playerRect();
    player.onGround = false;

    for (const p of world.platforms) {
      const pr = { x: p.x, y: p.y, w: p.w, h: p.h };
      if (!rectsOverlap(rect, pr)) continue;
      if (axis === "x") {
        if (player.vx > 0) player.x = p.x - rect.w;
        else if (player.vx < 0) player.x = p.x + p.w;
        player.vx = 0;
      } else {
        if (player.vy > 0) {
          player.y = p.y - rect.h;
          player.vy = 0;
          player.onGround = true;
          player.coyote = 0.12;
          player.jumpsLeft = 2;
          if (p.type === "fragile") {
            p.fallTimer = (p.fallTimer || 0) + 1;
          }
        } else if (player.vy < 0) {
          player.y = p.y + p.h;
          player.vy = 0;
        }
      }
    }

    if (!player.onGround) player.coyote = Math.max(player.coyote, 0);
  }

  function updatePlatforms(dt) {
    for (const p of world.platforms) {
      if (p.type === "moving") {
        p.x = p.startX + Math.sin(perfTime * p.speed) * p.range;
      }
      if (p.type === "fragile" && p.fallTimer > 0) {
        p.fallTimer += dt;
        if (p.fallTimer > 0.6) {
          p.y += 6;
          if (p.y > world.height + 100) p.dead = true;
        }
      }
    }
    world.platforms = world.platforms.filter(p => !p.dead);
  }

  function updateHazards(dt) {
    for (const h of world.hazards) {
      if (h.type === "saw") {
        h.phase += h.speed;
        h.y += Math.sin(h.phase) * 0.7;
      }
      if (h.type === "laser") {
        h.phase += h.speed;
      }
    }
  }

  function updateEnemies(dt) {
    for (const e of world.enemies) {
      e.timer += dt;
      if (e.type === "walker") {
        e.x += e.vx;
        if (e.patrol) {
          if (e.x < e.patrol[0] || e.x > e.patrol[1]) e.vx *= -1;
        }
      }
      if (e.type === "shooter") {
        if (e.timer > 1.6) {
          e.timer = 0;
          world.bullets.push({
            x: e.x + e.w / 2,
            y: e.y + 8,
            vx: (player.x < e.x ? -1 : 1) * (2.6 + state.level * 0.05),
            vy: -0.5 + rand(),
            owner: "enemy",
            life: 180,
          });
          playTone(240, "sawtooth", 0.08, 0.2);
        }
      }
      if (rectsOverlap(playerRect(), e)) {
        if (player.invuln <= 0) killPlayer();
      }
    }
  }

  function updatePickups() {
    for (const p of world.pickups) {
      if (p.used) continue;
      const rect = { x: p.x - 8, y: p.y - 8, w: 16, h: 16 };
      if (rectsOverlap(playerRect(), rect)) {
        p.used = true;
        if (p.type === "buff") {
          player.invuln = Math.max(player.invuln, 0.6);
          playTone(520, "sine", 0.12, 0.3);
        } else {
          player.vx *= 0.6;
          player.vy += 2.5;
          playTone(120, "square", 0.14, 0.3);
        }
      }
    }
  }

  function updatePortals() {
    for (const p of world.portals) {
      if (!p.active) continue;
      if (rectsOverlap(playerRect(), p)) {
        if (state.level === 25) {
          if (world.boss && world.boss.hp > 0) return;
          nextLevel();
          return;
        }
        if (p.targetX) {
          player.x = p.targetX;
          player.y -= 80;
        } else {
          nextLevel();
          return;
        }
        playTone(420, "triangle", 0.2, 0.4);
      }
    }
  }

  function updateBullets(dt) {
    for (const b of world.bullets) {
      b.x += b.vx;
      b.y += b.vy;
      b.life -= 1;
      if (b.owner === "player") {
        for (const e of world.enemies) {
          if (rectsOverlap({ x: b.x - 4, y: b.y - 4, w: 8, h: 8 }, e)) {
            e.hp -= 1;
            b.life = 0;
            spawnParticle(b.x, b.y, "rgba(160,255,255,0.9)", 8, 2, 20);
            playTone(360, "sine", 0.08, 0.3);
          }
        }
        if (world.boss && rectsOverlap({ x: b.x - 4, y: b.y - 4, w: 8, h: 8 }, world.boss)) {
          world.boss.hp -= 2;
          b.life = 0;
          spawnParticle(b.x, b.y, "rgba(255,180,180,0.9)", 12, 3, 24);
        }
      } else if (b.owner === "enemy") {
        if (rectsOverlap(playerRect(), { x: b.x - 4, y: b.y - 4, w: 8, h: 8 })) {
          if (player.invuln <= 0) killPlayer();
          b.life = 0;
        }
      }
    }
    world.bullets = world.bullets.filter(b => b.life > 0);
    world.enemies = world.enemies.filter(e => e.hp > 0);
  }

  function updateBoss(dt) {
    const boss = world.boss;
    if (!boss) return;
    boss.timer += dt;
    boss.attackTimer += dt;

    const hpRatio = boss.hp / boss.maxHp;
    boss.phase = hpRatio > 0.66 ? 1 : hpRatio > 0.33 ? 2 : 3;

    const speed = boss.phase === 1 ? 1.8 : boss.phase === 2 ? 2.4 : 3.2;
    boss.x += boss.vx * speed;
    if (boss.x < 200 || boss.x > world.width - 200) boss.vx *= -1;

    if (boss.dashCooldown > 0) boss.dashCooldown -= dt;

    if (boss.attackTimer > (boss.phase === 1 ? 2.2 : boss.phase === 2 ? 1.6 : 1.1)) {
      boss.attackTimer = 0;
      const roll = rand();
      if (roll < 0.4) bossBulletHell(boss.phase);
      else if (roll < 0.7) bossGroundSlam();
      else bossDash();
    }

    if (rectsOverlap(playerRect(), boss)) {
      if (player.invuln <= 0) killPlayer();
    }

    if (boss.hp <= 0) {
      world.boss = null;
      spawnParticle(boss.x, boss.y, "rgba(255,200,200,0.9)", 40, 4, 60);
      playNoise(0.4, 0.5);
    }
  }

  function bossBulletHell(phase) {
    const boss = world.boss;
    const count = phase === 1 ? 8 : phase === 2 ? 14 : 20;
    for (let i = 0; i < count; i++) {
      const ang = (Math.PI * 2 / count) * i + rand() * 0.2;
      world.bullets.push({
        x: boss.x + boss.w / 2,
        y: boss.y + boss.h / 2,
        vx: Math.cos(ang) * (2.2 + phase * 0.6),
        vy: Math.sin(ang) * (2.2 + phase * 0.6),
        owner: "enemy",
        life: 220,
      });
    }
    playTone(200, "sawtooth", 0.18, 0.4);
    state.shake = 8;
  }

  function bossGroundSlam() {
    const boss = world.boss;
    for (let i = 0; i < 7; i++) {
      world.hazards.push({
        x: boss.x - 200 + i * 70,
        y: 640,
        w: 32,
        h: 20,
        type: "spike",
        temp: true,
        life: 80,
      });
    }
    playNoise(0.2, 0.4);
    state.shake = 12;
  }

  function bossDash() {
    const boss = world.boss;
    if (boss.dashCooldown > 0) return;
    boss.dashCooldown = 2.0;
    boss.vx = player.x < boss.x ? -1 : 1;
    boss.x += boss.vx * 200;
    spawnParticle(boss.x, boss.y + boss.h, "rgba(255,120,120,0.9)", 20, 4, 40);
    playTone(140, "square", 0.2, 0.4);
  }

  function updateHazardDamage() {
    const rect = playerRect();
    for (const h of world.hazards) {
      if (h.temp) {
        h.life -= 1;
        if (h.life <= 0) h.dead = true;
      }
      if (h.type === "laser") {
        const active = Math.sin(h.phase) > 0.2;
        if (active) {
          const beam = { x: h.x, y: h.y, w: h.w, h: h.h };
          if (rectsOverlap(rect, beam)) killPlayer();
        }
      } else if (rectsOverlap(rect, h)) {
        if (player.invuln <= 0) killPlayer();
      }
    }
    world.hazards = world.hazards.filter(h => !h.dead);
  }

  function updateParticles() {
    for (const p of world.particles) {
      p.life -= 1;
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.05;
    }
    world.particles = world.particles.filter(p => p.life > 0);
  }

  function attack() {
    if (player.attackCooldown > 0) return;
    player.attackCooldown = 0.25;
    const dir = input.mouse.x < canvas.width / 2 ? -1 : 1;
    world.bullets.push({
      x: player.x + player.w / 2 + dir * 18,
      y: player.y + player.h * 0.5,
      vx: dir * 8,
      vy: 0,
      owner: "player",
      life: 90,
    });
    spawnParticle(player.x + player.w / 2, player.y + player.h * 0.5, "rgba(150,255,255,0.9)", 8, 2, 20);
    playTone(420, "triangle", 0.08, 0.3);
  }

  function updateCamera(dt) {
    const targetX = player.x - canvas.clientWidth / 2 + player.w / 2;
    const targetY = player.y - canvas.clientHeight / 2 + player.h / 2 - 40;
    state.camera.tx = targetX;
    state.camera.ty = targetY;
    if (state.camera.manual) {
      state.camera.offsetX = clamp(state.camera.offsetX, -200, 200);
      state.camera.offsetY = clamp(state.camera.offsetY, -160, 160);
    } else {
      state.camera.offsetX = lerp(state.camera.offsetX, 0, 0.1);
      state.camera.offsetY = lerp(state.camera.offsetY, 0, 0.1);
    }
    state.camera.x = lerp(state.camera.x, state.camera.tx + state.camera.offsetX, 0.08);
    state.camera.y = lerp(state.camera.y, state.camera.ty + state.camera.offsetY, 0.08);
  }

  function drawBackground() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const grad = ctx.createLinearGradient(0, 0, 0, h);
    grad.addColorStop(0, "#0b1020");
    grad.addColorStop(1, "#020307");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);

    const parallax = [0.2, 0.35, 0.5];
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = `rgba(40, 60, 80, ${0.18 - i * 0.04})`;
      const offset = state.camera.x * parallax[i];
      for (let x = -200; x < w + 200; x += 220) {
        const y = h * 0.55 + Math.sin((x + offset) * 0.01 + i) * (20 + i * 10);
        ctx.beginPath();
        ctx.moveTo(x + offset * 0.05, h);
        ctx.quadraticCurveTo(x + 110 + offset * 0.05, y, x + 220 + offset * 0.05, h);
        ctx.closePath();
        ctx.fill();
      }
    }
  }

  function drawWorld() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.save();
    const shakeX = (Math.random() * 2 - 1) * state.shake;
    const shakeY = (Math.random() * 2 - 1) * state.shake;
    ctx.translate(-state.camera.x + shakeX, -state.camera.y + shakeY);

    for (const d of world.decorations) {
      ctx.fillStyle = d.color;
      ctx.fillRect(d.x, d.y, d.w, d.h);
    }

    for (const p of world.platforms) {
      ctx.fillStyle = p.type === "fragile" ? "rgba(120,120,120,0.7)" : "rgba(200,220,255,0.08)";
      ctx.fillRect(p.x, p.y, p.w, p.h);
      if (p.type === "moving") {
        ctx.strokeStyle = "rgba(120,180,255,0.3)";
        ctx.strokeRect(p.x, p.y, p.w, p.h);
      }
    }

    for (const hzd of world.hazards) {
      if (hzd.type === "spike") {
        ctx.fillStyle = "rgba(255,90,90,0.8)";
        ctx.beginPath();
        const count = Math.floor(hzd.w / 12);
        for (let i = 0; i <= count; i++) {
          const x = hzd.x + i * (hzd.w / count);
          const y = hzd.y + (i % 2 === 0 ? hzd.h : 0);
          ctx.lineTo(x, y);
        }
        ctx.lineTo(hzd.x + hzd.w, hzd.y + hzd.h);
        ctx.closePath();
        ctx.fill();
      } else if (hzd.type === "saw") {
        ctx.strokeStyle = "rgba(255,130,130,0.9)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(hzd.x + hzd.w / 2, hzd.y + hzd.h / 2, hzd.w / 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.lineWidth = 1;
      } else if (hzd.type === "laser") {
        const active = Math.sin(hzd.phase) > 0.2;
        ctx.fillStyle = active ? "rgba(255,80,160,0.7)" : "rgba(255,80,160,0.2)";
        ctx.fillRect(hzd.x, hzd.y, hzd.w, hzd.h);
      }
    }

    for (const e of world.enemies) {
      ctx.fillStyle = "rgba(255,200,120,0.8)";
      ctx.fillRect(e.x, e.y, e.w, e.h);
    }

    for (const p of world.pickups) {
      if (p.used) continue;
      ctx.fillStyle = p.type === "buff" ? "rgba(120,255,180,0.8)" : "rgba(255,180,120,0.8)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6 + Math.sin(perfTime * 3) * 1.5, 0, Math.PI * 2);
      ctx.fill();
    }

    for (const portal of world.portals) {
      ctx.strokeStyle = "rgba(140,240,255,0.9)";
      ctx.lineWidth = 2;
      ctx.strokeRect(portal.x, portal.y, portal.w, portal.h);
      ctx.lineWidth = 1;
    }

    for (const b of world.bullets) {
      ctx.fillStyle = b.owner === "player" ? "rgba(150,255,255,0.9)" : "rgba(255,140,140,0.9)";
      ctx.fillRect(b.x - 3, b.y - 3, 6, 6);
    }

    if (world.boss) {
      ctx.fillStyle = "rgba(255,120,140,0.9)";
      ctx.fillRect(world.boss.x, world.boss.y, world.boss.w, world.boss.h);
    }

    ctx.fillStyle = "rgba(230,240,255,0.92)";
    const ph = player.crouch ? player.h * 0.6 : player.h;
    ctx.fillRect(player.x, player.y, player.w, ph);

    for (const p of world.particles) {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }

    ctx.restore();

    if (state.shake > 0) state.shake *= 0.88;

    const vignette = ctx.createRadialGradient(w / 2, h / 2, w * 0.2, w / 2, h / 2, w * 0.6);
    vignette.addColorStop(0, "rgba(0,0,0,0)");
    vignette.addColorStop(1, "rgba(0,0,0,0.45)");
    ctx.fillStyle = vignette;
    ctx.fillRect(0, 0, w, h);

    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "#fff";
    for (let i = 0; i < 120; i++) {
      const x = Math.random() * w;
      const y = Math.random() * h;
      ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  let lastTime = 0;
  let perfTime = 0;
  function loop(t) {
    requestAnimationFrame(loop);
    const dt = Math.min((t - lastTime) / 1000, 0.033);
    lastTime = t;
    perfTime += dt;

    if (!state.running) {
      drawBackground();
      return;
    }

    state.time += dt;
    hudLevel.textContent = state.level;
    hudTimer.textContent = state.time.toFixed(1);

    if (state.level >= 10 && state.time > state.par) {
      world.gravity = 0.9 + (state.time - state.par) * 0.02;
    } else {
      world.gravity = 0.8;
    }

    updatePlayer(dt);
    updatePlatforms(dt);
    updateHazards(dt);
    updateEnemies(dt);
    updateBullets(dt);
    updatePickups();
    updateHazardDamage();
    updateBoss(dt);
    updatePortals();
    updateParticles();
    updateCamera(dt);

    drawBackground();
    drawWorld();

    if (world.boss) {
      bossBarFill.style.width = `${(world.boss.hp / world.boss.maxHp) * 100}%`;
    }

    musicStepTick(dt);
  }

  function handleKey(e, down) {
    if (e.repeat) return;
    switch (e.code) {
      case "KeyA": input.left = down; break;
      case "KeyD": input.right = down; break;
      case "KeyW": input.up = down; if (down) input.jumpBuffer = 0.15; break;
      case "ArrowUp": if (down) input.jumpBuffer = 0.15; break;
      case "Space": input.jump = down; if (down) input.jumpBuffer = 0.15; break;
      case "ControlLeft":
      case "ControlRight": input.down = down; break;
      case "ShiftLeft":
      case "ShiftRight": input.sprint = down; break;
      case "KeyH": if (down) toggleHint(); break;
      case "KeyM": if (down) toggleMute(); break;
      case "KeyJ": if (down) attack(); break;
      default: break;
    }
  }

  function toggleHint() {
    hint.style.display = hint.style.display === "none" ? "block" : "none";
  }

  function toggleMute() {
    state.muted = !state.muted;
    updateMute();
  }

  window.addEventListener("keydown", (e) => {
    initAudio();
    handleKey(e, true);
  });
  window.addEventListener("keyup", (e) => handleKey(e, false));

  canvas.addEventListener("mousedown", (e) => {
    initAudio();
    if (e.button === 0) {
      input.mouse.down = true;
      attack();
    }
    if (e.button === 2) {
      input.mouse.rdown = true;
      state.camera.manual = true;
      input.mouse.dragX = e.clientX;
      input.mouse.dragY = e.clientY;
    }
  });
  canvas.addEventListener("mouseup", (e) => {
    if (e.button === 0) input.mouse.down = false;
    if (e.button === 2) {
      input.mouse.rdown = false;
      state.camera.manual = false;
    }
  });
  canvas.addEventListener("mousemove", (e) => {
    input.mouse.x = e.clientX;
    input.mouse.y = e.clientY;
    if (input.mouse.rdown) {
      state.camera.offsetX += (e.clientX - input.mouse.dragX) * 0.6;
      state.camera.offsetY += (e.clientY - input.mouse.dragY) * 0.6;
      input.mouse.dragX = e.clientX;
      input.mouse.dragY = e.clientY;
    }
  });
  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  startBtn.addEventListener("click", () => {
    initAudio();
    state.running = true;
    state.level = 1;
    state.attempt = 0;
    generateLevel(state.level);
  });
  muteBtn.addEventListener("click", toggleMute);
  hintBtn.addEventListener("click", toggleHint);

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
